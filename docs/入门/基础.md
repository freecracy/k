# 基础

## 基本概念

### master

将集群中的机器划分为一个 master 和一些 node,master 上运行着集群管理相关的进程 kube-apiserver、kube-controller-manager、kube-scheduler.这些进程实现整个集群的资源管理、pod 调度、弹性伸缩、安全控制、系统监控.

集群控制节点,基本上所有控制命令都发给他他负责具体的执行过程(高可用部署方案为3台机器).

主要以下关键进程:

1. kube-server : 所有资源增删改查的唯一入口,集群控制的唯一入口
2. kube-controller-manager : 所有资源对象的自动化控制中心
3. kube-scheduler : 负责资源调度

> master 上还需要部署 etcd 服务,因为所有资源对象的数据都保存在 etcd 中.

### node

node 作为集群中的工作节点.在 node 上 k8s 管理的最小单元是 pod,在 node 上运行着 kubelet、kube-proxy 服务进程,这些服务进程负责 pod 创建、启动、监控、重启、销毁、以及软件模式的负载均衡.

主要以下关键进程:

1. kubelet : 负责 pod 对应容器创建、启停等任务,同时与 master 协作,实现集群管理基本功能.
2. kube-proxy : 实现 k8s service 通信与负载均衡机制等重要组件
3. docker : 负责本机容器的创建和管理

只要 node 上正确配置以上进程可以在运行期间动态增加到 k8s 集群中.默认情况下 kubelet 会向 master 注册自己,是 k8s 推荐的 node 管理方式.一旦 node 纳入集群管理范围, kubelet 会定时向 master 汇报自身情况(cpu、内存、哪些pod在运行、docker版本等), node 超过时间不上报信息会被 master 判定失联, node 状态标记为不可用

```shell
kubectl get nodes # 查看 node 数量
kubectl describe node <node_name> # 查看 node 详细信息
```

1. 基本信息 : 名称、标签、创建时间等
2. 当前运行状态 : 启动后会自我检测,磁盘空间、内存空间、网络状况、pid 资源一切正常后会设置为 ready 状态
3. 主机地址与主机名
4. 资源数量 : cpu、内存、最大调度 pod数量
5. 主机信息 : 主机 ID、系统 uuid、内核版本、操作系统版本、docker 版本、kubelet、kube-proxy 版本

### pod

pod 运行在一个被称为 node 的环境中,可以是物理机也可以是虚拟机,通常一个节点上运行几百个 pod,其次在每个 pod 中都运行着一个被称为 pause 的容器.其它容器则为业务容器.这些业务容器共享 pause 容器(pod 的根容器)的网络栈和 volume 挂载卷.通讯较为高效,所以可以把一组相关服务进程放入同一个 pod 中.

k8s 为每个 pod 分配唯一 ip 地址 pod ip,一个 pod 内的多个容器共享 pod ip,每个 pod 都提供一个独立的 endpoint (IP + container port).

静态 pod : 区别普通 pod,没被存在 etcd 里,他被放在某个 node 上一个文件里并且只在此 node 上启动运行,而普通 pod 一旦创建就会在 etcd 中存储,随后被调度到 node 上, pod 被对应 node 上 kubelet 进程实例化一组相关 docker 容器启动.如果某个容器停止,k8s 会自动检测并重新启动整个 pod(重启 pod 里所有容器),如果 pod 所在 node 宕机会将这个 node 上所有 pod 重新调度到其它节点上.

可以配置 cpu 和内存,通常以千分之一的 cpu 配额为最小单位、用 m 来表示 100-300 m 表示占用 0.1-0.3 个 cpu.

Requests : 该资源的最小申请量

Limits : 该资源的最大使用量,不能被突破,试图使用超过这个量的资源时可能会被 k8s 杀掉并重启

```shell
kubectl get endpoints # 查看 endpoints
```

### label

label 是一个 key=value 键值对,key 和 value 都由用户自己定义,可以被附加到各种资源上,一个资源对象可以定义任意数量的 label, 同一个 label 也可以添加到任意数量的资源对象上.

```yaml
selector : # 标签选择器
	app : myweb
```

#### 常用label

1. 版本标签 : “release”:“stable”、“release”:“canary”
2. 环境标签 : “environment”:“dev“、”environment“:”qa“、”environment“:”production“
3. 架构标签 : ”tier“:“frontend”、”tier”:“backend”、“tier”:“middleware”

#### 标签选择器

1. name = redis-slave (基于等式)
2. env != production
3. name in (redis-master,redis-slave) (基于集合)
4. name not in (php-frontend)

多个标签选择器表达式之间用逗号分隔,几个条件之间是 AND 关系.

```yaml
selector:
	matchlabels:
		app : myweb
	matchexpressions: # 可用条件运算符 In、NotIn、Exists、DoesNotExist
		- (key: tier, operator: In, values:  [frontend])
		-	(key: environment, operator: Notin, values:  [dev]}
```

### service

pod 的 endpoint 地址会随着 pod 的销毁和重新创建发生改变,但 service 的 cluster ip 在整个生命周期内不会改变.只要用 service name 与 service 的 cluster ip 做 DNS 域名映射即可解决服务发现问题.

### job

1.5 版本后引入 cronjob,解决定时反复执行的问题.

### volume

需要先在 pod 上声明,然后容器引用并挂载在容器某个目录上.

```yaml
spec:
	volumes:
		- name: datavol
			emptydir: {}
	containers:
		-	name: tomcat-demo
			lmage: tomcat
			volumemounts:
				-	mountrath /mydata-data
					name: datavol
```

* emptyDir : 是在 pod 分配到 node 时创建,初始内容为空,是自动分配到目录,pod 从 node 上移除时,数据会永久删除,如一个容器从另一个容器获取数据,多容器共享该目录

* hostPath : 在 pod 上挂载宿主机上的文件或目录

  * 日志文件,永久保存
  * 访问宿主机文件

* gce & aws : 云厂商

* NFS : 网络文件系统,需要定义 NFS server

  ```yaml
	volumes:
		name: nfs
		nfs:
		server: nfs-server.localhost # 改为你的 NFS 服务器地址
		path: "/"
  ```

### configmap

容器配置文件集中化定义管理.相当于配置中心.docker 配置文件参数在镜像中,不能在启动容器后再修改容器里配置文件,然后用新的配置文件启动用户进程.

docker 解决方案:

1. 在运行容器时通过环境变量来传递参数
2. 通过 valume 将容器外等配置文件映射到容器内,缺点是我们必须在目标主机上先创建好对应的配置文件才能映射到容器里.

k8s 解决方案:

配置项当作 key=value 存储在 etcd 中.将存储在 etcd 中的 configmap 通过 volume 映射方式变成目标 pod 内的配置文件,不管目标 pod 被调度到哪台服务器上都会自动完成映射.如果 configmap 中 key-value 数据被修改,则映射到 pod 的配置文件也会自动更新.

### namespace

```yaml
apiversion: v1
kind: NameSpace
metadata:
	name: development
```

实现多租户的资源隔离.形成逻辑长分组的不通项目、小组、用户组.k8s 在启动后会创建一个名为 default 的 namespace

```shell
kubectl get namespaces # 查看命名空间
kubectl get pods --namespace=development # 默认 default 命名空间的资源对象
```

### annotation

注解与 label 类似,不同的是 label 具有严格的命名规则,定义的是 k8s 对象的元数据,并且用于 label selector.annotation 则是用户任意定义的附加信息.以便外部工具查找.

* build 信息、release信息、docker镜像
* 日志库、监控库、分析库等资源库地址信息
* 程序调试工具信息,如工具名称、版本号
* 团队信息

## 解决问题

### 服务扩容

为需要扩容的 service 关联的 pod 创建一个 RC(Replication controller),RC 文件包括以下内容:

1. 目标 pod 的定义
2. 目标 pod 需要运行的副本数
3. 要监控的目标 pod 的标签

k8s 通过 RC 中定义的 label 筛选出对应的 pod 实例并实时监控状态和数量,如果实例数量少于定义的副本数量会根据 RC 中定义的 pod 模版创建新的 pod,然后将此 pod 调度到合适的 node 上启动运行,直到 pod 数量达到预定目标.

### 服务升级

### event

事件的记录,记录事件的最早发生时间、最后重现时间、重复次数、发起者类型、导致事件的原因等、通常会被关联到具体的资源对象上,是排查故障的重要信息

## 资源

k8s 大部分概念如 node、pod、replication、controller、service 都可以看成一种资源对象,几乎所有资源对象都可以通过 kubectl 执行增、删、改、查并将结果保存在 etcd 中.其实是一个高度自动化的资源控制系统.通过跟踪对比 etcd 里保存的资源期望状态与当前环境中的实际资源状态的差异来实现自动控制和自动纠错.

### Annotations

该属性的存在相当于修改数据表时的预留字段,特性成熟后,增加为新的一列属性.

1. 通过备注,保存 json 存新特性
2. 直接修改增加一列

## 小记

1. 给每个 pod 贴上标签,然后给相应的 service 定义标签选择器,意味着该 service 作用于所有包含该标签的 pod.
2. 所有资源都可以用 yaml 和 json 描述,kind 区别资源类型,metadata 通常为资源通用属性,如 name、labels,容器组定义在 spec 一节
3. 服务发现 : DNS 系统
4. 配置中心 : configmap
